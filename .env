#!/usr/bin/env bash

# Copyright (C) 2021 Michael Joseph Walsh - All Rights Reserved
# You may use, distribute and modify this code under the
# terms of the the license.
#
# You should have received a copy of the license with
# this file. If not, please email <mjwalsh@nemonik.com>

cat_rendered_templates=false
save_container_images=true

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"

## urlencode <string>
##
## e.g., msged "rancher/k3d-proxy:v4.4.7" will return "rancher%2Fk3d-proxy%3Av4.4.7%0A"
function urlencode() {
    old_lc_collate=$LC_COLLATE
    LC_COLLATE=C

    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:i:1}"
        case $c in
            [a-zA-Z0-9.~_-]) printf "$c" ;;
            ' ') printf "%%20" ;;
            *) printf '%%%02X' "'$c" ;;
        esac
    done

    LC_COLLATE=$old_lc_collate
}

## urldecode <string>
##
## e.g., msged "rancher%2Fk3d-proxy%3Av4.4.7%0A" will return "rancher/k3d-proxy:v4.4.7"
function urldecode() {

    local url_encoded="${1//+/ }"
    printf '%b' "${url_encoded//%/\\x}"
}

function join_by {

  local delimiter=${1-}
  local array=${2-}
  if shift 2; then
	printf %s "$array" "${@/#/$delimiter}"
  fi
}

##
## get_image_name <string>
##
## e.g., msged "drone:2.0" echos "drone")
##
function get_image_name() {

  IFS=':' read -ra parts <<< "${1}"

  if [ ${#parts[@]} == 1 ]; then
    ## no tag, so return the messaged value
    ##
    echo $1
  elif [ ${#parts[@]} == 2 ]; then
    ## handle drone:2.0
    ##
    echo "${parts[0]}"
  elif [ ${#parts[@]} == 3 ]; then
    ## handle docker.io/nemonik/drone:2.0 and docker.io:5000/nemonik/drone:2.0
    ##
    IFS='/' read -ra parts <<< "${parts[1]}"

    if [[ "${parts[0]}" =~ ^[0-9]+$ ]]; then
      # remove port if it exists from parts array
      unset parts[0];
    fi

    # combine all the parts
    name=$(printf "/%s" "${parts[@]}")
    name=${name:1}

    echo "${name}"

  else
    echo "Malformed image name: ${1}"
    exit 1
  fi
}

## Returns the image's tag when messaged .
##
## e.g., msged "redis:5.0.9" echos "5.0.9".
##
function get_image_tag() {

  IFS=':' read -ra parts <<< "$1"

  if [ ${#parts[@]} == 1 ]; then
    ## Not tag, so return "latest"
    ##
    echo "latest"
  else

    echo "${parts[-1]}"
  fi

}

## Call envsbt to replace the environment variables
## in a template and saves the resulting file.
##
## template_file <string> <string>
##
## e.g., msged "template" "rendered" will render
## environmental variable in template an
##
function template_file() {

  notify "Using the $1 template to generate the $2:"

  envsubst <$1 > $2

  if [ "$cat_rendered_templates" == true ]; then
    cat $2
  fi

}

## When messaged a hashmap of images it will
## pull them from the docker hub, tag them for
## private container regitry and push them it
## into it.  It will also create variables for
## the image name and tage using they key for
## each image.
##
function images_into_registry() {

  notify "Pulling images and placing into k3d-registry..."

  # images passed by reference
  local -n images=$1

  for image in "${!images[@]}"; do

    local image_name=$(get_image_name ${images[$image]})
    local image_tag=$(get_image_tag ${images[$image]})

    eval "${image}_image_name=\"${image_name}\""

    eval "${image}_image_tag=\"${image_tag}\""

    notify "Pulling, tagging and pushing ${image_name}:${image_tag} into ${registry_name}:${egistry_port} container image repository..."

    if [ "$(docker images ${images[$image]} | wc -l)" = "1" ]; then
      if [ "${save_container_images}" = "true" ]; then
        if [[ -f "${SCRIPT_DIR}/image_cache/$(urlencode ${images[$image]}).tar" ]]; then
	  notify "Loading image for saved image file located at ${SCRIPT_DIR}/image_cache/$(urlencode ${images[$image]}).tar"
  	  docker load -i ${SCRIPT_DIR}/image_cache/$(urlencode ${images[$image]}).tar
        fi
      else
        notify "Pulling image from remote registry..."
        docker pull ${images[$image]}
      fi
    else
      notify "All ready have ${images[$image]} in docker cache."
    fi

    docker pull ${images[$image]}
    docker tag ${images[$image]} ${registry_name}:${registry_port}/${images[$image]}
    docker push ${registry_name}:${registry_port}/${images[$image]}

    if [ "${save_container_images}" = "true" ]; then
      if [[ -f "${SCRIPT_DIR}/image_cache/$(urlencode ${images[$image]}).tar" ]]; then
        notify "${images[$image]} already cached in ${SCRIPT_DIR}/image_cache/"
      else
	notify "Saving ${images[$image]} to ${SCRIPT_DIR}/image_cache/$(urlencode ${images[$image]}).tar"
        docker save ${images[$image]} > ${SCRIPT_DIR}/image_cache/$(urlencode ${images[$image]}).tar
      fi
    fi
  done

}

## Echo text messaged in green to notify.
##
function notify() {

  local green='\033[0;32m'
  local no_color='\033[0m'

  echo -e "${green}$1${no_color}"
}

## Echo text messaged in red to indicate an error.
##
function error() {

  local red='\033[0;31m'
  local no_color='\033[0m'

  echo -e "${red}$1${no_color}"
}

## Echo text message in yellow to indicate a warning.
##
function warn() {

  local yellow='\033[1;33m'
  local no_color='\033[0m'

  echo -e "${yellow}$1${no_color}"

}

## Echo text message in blue to indicate asking for input.
##
function ask_for_input() {

  local light_blue='\033[1;34m'
  local no_color='\033[0m'

  echo -e "${light_blue}$1${no_color}"

}

if [ ! $skip_encrypted_variables ]; then

  notify "Attempting to load secrets from ${SCRIPT_DIR}/vault..."

  if file $SCRIPT_DIR/vault | grep -q "openssl"; then

    if [ -z "$VAULT_PASSWORD" ]; then

      ask_for_input "Enter vault password to decrypt vault to access secured variables in ${SCRIPT_DIR}/vault:"
      read -s VAULT_PASSWORD

    else

      warn "Using VAULT_PASSWORD env variable to access secured variables contained in the ${SCRIPT_DIR}/vault..."

    fi

    eval "$(openssl enc -base64 -d -aes-256-cbc -md sha512 -pbkdf2 -iter 100000 -salt -pass pass:${VAULT_PASSWORD} -in ${SCRIPT_DIR}/vault)"

  else
    warn "${SCRIPT_DIR}/vault was found unecrypted and used..."
    source ${SCRIPT_DIR}/vault
  fi
fi

## Set variables for project
##

notify "Setting unsecured variables into current context..."

domain="nemonik.com"

## Vagrant
##
vagrant_enabled=true
varant_box="archlinux/archlinux"
vagrant_memory=32764
vagrant_cpus=4
vagrant_disksize="200GB"

## Private container registry
##
registry_name="k3d-registry.nemonik.com"
registry_port="5000"


## pullthrough egistry container registry
pullthrough_registry_enabled=true
pullthrough_registry_port="5001"
pullthrough_registry_name="hands-on-devops-pullthrough-registry"

## K3d cluster
##

# The cluster's name must be limited to 'Aa-Zz', '0-9' or '-' characters
k3d_cluster_name="hands-on-devops-class"
k3d_server_count="1"
k3d_agent_count="1"
k3s_airgap_images_url="https://github.com/k3s-io/k3s/releases/download/v1.21.2%2Bk3s1/k3s-airgap-images-amd64.tar.gz"
k3s_canonical_image="rancher/k3s:v1.21.2-k3s1"
declare -A k3d_images=( \
   ["k3s"]="nemonik/k3s:v1.21.2-k3s1" \
   ["proxy"]="rancher/k3d-proxy:v4.4.7")


## Traefik
#
traefik_version="2.2.8"
traefik_namespace="traefik"
# traefik_tls_crt is in ./vault
# traefik_tls_key is in ./vault
declare -A traefik_images=( \
  ["traefik"]="traefik:${traefik_version}")


## Used for testing
##
test_namespace="test"
test_fdqn="test.${domain}"
test_protocol="https"
declare -A test_images=( \
  ["nginx"]="nginx:1.19-alpine")


## Taiga
##
taiga_version="latest"
taiga_namespace="taiga"
taiga_fdqn="taiga.${domain}"
taiga_protocol="https"
taiga_port=443
taiga_user=root
taiga_password=password
declare -A taiga_images=( \
  ["rabbitmq"]="rabbitmq:3.7-management-alpine" \
  ["taiga_back"]="taigaio/taiga-back:${taiga_version}" \
  ["postgres"]="postgres:12.3" \
  ["taiga_events"]="taigaio/taiga-events:${taiga_version}" \
  ["taiga_front"]="taigaio/taiga-front:${taiga_version}" \
  ["nginx"]="nginx:1.19-alpine" \
  ["taiga_protected"]="taigaio/taiga-protected:${taiga_version}")


## GitLab
##
gitlab_version="13.12.0"
gitlab_namespace="gitlab"
gitlab_fdqn="gitlab.${domain}"
gitlab_protocol="https"
gitlab_port=443
gitlab_root_password="password"

declare -A gitlab_images=( \
  ["redis"]="redis:5.0.9" \
  ["postgresql"]="sameersbn/postgresql:11-20200524" \
  ["gitlab"]="sameersbn/gitlab:${gitlab_version}")


## Drone
##
drone_namespace="drone"
drone_fdqn="drone.${domain}"
drone_protocol="https"
drone_runner_replica_count=1
declare -A drone_images=( \
  ["postgresql"]="sameersbn/postgresql:11-20200524" \
  ["drone"]="nemonik/drone:latest" \
  ["drone_runner_kube"]="drone/drone-runner-kube:latest" \
  ["kubernetes_secrets"]="drone/kubernetes-secrets:latest")


## PlantUML Server
##
plantuml_server_namespace="plantuml"
plantuml_server_fdqn="plantuml.${domain}"
plantuml_server_protocol="https"
declare -A plantuml_server_images=( \
  ["plantuml_server"]="plantuml/plantuml-server:latest")


## SonarQube
##
sonarqube_namespace="sonarqube"
sonarqube_fdqn="sonar.${domain}"
sonarqube_protocol="https"
sonarqube_port="443"
declare -A sonarqube_images=( \
  ["sonarqube"]="sonarqube:8.5.1-community" \
  ["busybox"]="busybox:1.32" \
  ["postgresql"]="bitnami/postgresql:11.7.0-debian-10-r26")


## Heimdall2
##
heimdall_namespace="heimdall2"
heimdall_fdqn="heimdall.${domain}"
heimdall_protocol="https"
heimdall_port="443"
heimdall_database_password=`openssl rand -hex 33`
heimdall_jwt_secret=`openssl rand -hex 64`
declare -A heimdall_images=( \
  ["postgres"]="postgres:13" \
  ["heimdall"]="mitre/heimdall2:2.4.8")


declare -A class_images=( \
  ["docker"]="plugins/docker:latest" \
  ["golang"]="golang:1.16.5" \
  ["bitnami_kubectl"]="bitnami/kubectl:1.21.1" \
  ["selenium_standalone_chrome"]="selenium/standalone-chrome:3.141" \
  ["python"]="python:3.9.6" \
  ["owasp_zap2docker"]="owasp/zap2docker-stable:2.8.0")


## CoreDNS entries
##
coredns_entries=( "${gitlab_fdqn}" "${drone_fdqn}" "${taiga_fdqn}" "${sonarqube_fdqn}" "${plantuml_server_fdqn}" "${heimdall_fdqn}" "${registry_name}" "helloworld.nemonik.com")

